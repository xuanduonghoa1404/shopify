{"ast":null,"code":"import debounce$1 from 'lodash/debounce';\nimport { stackedContent } from '../breakpoints.js';\nimport { spacingLoose } from '@shopify/polaris-tokens';\nimport { scrollable, dataPolarisTopBar } from '../../components/shared.js';\nimport { getRectForNode } from '../geometry.js';\nvar SIXTY_FPS = 1000 / 60;\n\nclass StickyManager {\n  constructor(container) {\n    this.stickyItems = [];\n    this.stuckItems = [];\n    this.container = null;\n    this.topBarOffset = 0;\n    this.handleResize = debounce$1(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    this.handleScroll = debounce$1(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n\n  registerStickyItem(stickyItem) {\n    this.stickyItems.push(stickyItem);\n  }\n\n  unregisterStickyItem(nodeToRemove) {\n    var nodeIndex = this.stickyItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stickyItems.splice(nodeIndex, 1);\n  }\n\n  setContainer(el) {\n    this.container = el;\n\n    if (isDocument(el)) {\n      this.setTopBarOffset(el);\n    }\n\n    this.container.addEventListener('scroll', this.handleScroll);\n    window.addEventListener('resize', this.handleResize);\n    this.manageStickyItems();\n  }\n\n  removeScrollListener() {\n    if (this.container) {\n      this.container.removeEventListener('scroll', this.handleScroll);\n      window.removeEventListener('resize', this.handleResize);\n    }\n  }\n\n  manageStickyItems() {\n    if (this.stickyItems.length <= 0) {\n      return;\n    }\n\n    var scrollTop = this.container ? scrollTopFor(this.container) : 0;\n    var containerTop = getRectForNode(this.container).top + this.topBarOffset;\n    this.stickyItems.forEach(stickyItem => {\n      var {\n        handlePositioning\n      } = stickyItem;\n      var {\n        sticky,\n        top,\n        left,\n        width\n      } = this.evaluateStickyItem(stickyItem, scrollTop, containerTop);\n      this.updateStuckItems(stickyItem, sticky);\n      handlePositioning(sticky, top, left, width);\n    });\n  }\n\n  evaluateStickyItem(stickyItem, scrollTop, containerTop) {\n    var {\n      stickyNode,\n      placeHolderNode,\n      boundingElement,\n      offset,\n      disableWhenStacked\n    } = stickyItem;\n\n    if (disableWhenStacked && stackedContent().matches) {\n      return {\n        sticky: false,\n        top: 0,\n        left: 0,\n        width: 'auto'\n      };\n    }\n\n    var stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(spacingLoose, 10) : this.getOffset(stickyNode);\n    var scrollPosition = scrollTop + stickyOffset;\n    var placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;\n    var top = containerTop + stickyOffset;\n    var width = placeHolderNode.getBoundingClientRect().width;\n    var left = placeHolderNode.getBoundingClientRect().left;\n    var sticky;\n\n    if (boundingElement == null) {\n      sticky = scrollPosition >= placeHolderNodeCurrentTop;\n    } else {\n      var _stickyNode$firstElem;\n\n      var stickyItemHeight = stickyNode.getBoundingClientRect().height || ((_stickyNode$firstElem = stickyNode.firstElementChild) == null ? void 0 : _stickyNode$firstElem.getBoundingClientRect().height) || 0;\n      var stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;\n      sticky = scrollPosition >= placeHolderNodeCurrentTop && scrollPosition < stickyItemBottomPosition;\n    }\n\n    return {\n      sticky,\n      top,\n      left,\n      width\n    };\n  }\n\n  updateStuckItems(item, sticky) {\n    var {\n      stickyNode\n    } = item;\n\n    if (sticky && !this.isNodeStuck(stickyNode)) {\n      this.addStuckItem(item);\n    } else if (!sticky && this.isNodeStuck(stickyNode)) {\n      this.removeStuckItem(item);\n    }\n  }\n\n  addStuckItem(stickyItem) {\n    this.stuckItems.push(stickyItem);\n  }\n\n  removeStuckItem(stickyItem) {\n    var {\n      stickyNode: nodeToRemove\n    } = stickyItem;\n    var nodeIndex = this.stuckItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stuckItems.splice(nodeIndex, 1);\n  }\n\n  getOffset(node) {\n    if (this.stuckItems.length === 0) {\n      return 0;\n    }\n\n    var offset = 0;\n    var count = 0;\n    var stuckNodesLength = this.stuckItems.length;\n    var nodeRect = getRectForNode(node);\n\n    while (count < stuckNodesLength) {\n      var stuckNode = this.stuckItems[count].stickyNode;\n\n      if (stuckNode !== node) {\n        var stuckNodeRect = getRectForNode(stuckNode);\n\n        if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {\n          offset += getRectForNode(stuckNode).height;\n        }\n      } else {\n        break;\n      }\n\n      count++;\n    }\n\n    return offset;\n  }\n\n  isNodeStuck(node) {\n    var nodeFound = this.stuckItems.findIndex(({\n      stickyNode\n    }) => node === stickyNode);\n    return nodeFound >= 0;\n  }\n\n  setTopBarOffset(container) {\n    var topbarElement = container.querySelector(\":not(\".concat(scrollable.selector, \") \").concat(dataPolarisTopBar.selector));\n    this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;\n  }\n\n}\n\nfunction isDocument(node) {\n  return node === document;\n}\n\nfunction scrollTopFor(container) {\n  return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;\n}\n\nfunction horizontallyOverlaps(rect1, rect2) {\n  var rect1Left = rect1.left;\n  var rect1Right = rect1.left + rect1.width;\n  var rect2Left = rect2.left;\n  var rect2Right = rect2.left + rect2.width;\n  return rect2Right < rect1Left || rect1Right < rect2Left;\n}\n\nexport { StickyManager };","map":{"version":3,"sources":["/home/bss/Downloads/shopify/create-react-app/node_modules/@shopify/polaris/dist/esm/utilities/sticky-manager/sticky-manager.js"],"names":["debounce$1","stackedContent","spacingLoose","scrollable","dataPolarisTopBar","getRectForNode","SIXTY_FPS","StickyManager","constructor","container","stickyItems","stuckItems","topBarOffset","handleResize","manageStickyItems","leading","trailing","maxWait","handleScroll","setContainer","registerStickyItem","stickyItem","push","unregisterStickyItem","nodeToRemove","nodeIndex","findIndex","stickyNode","splice","el","isDocument","setTopBarOffset","addEventListener","window","removeScrollListener","removeEventListener","length","scrollTop","scrollTopFor","containerTop","top","forEach","handlePositioning","sticky","left","width","evaluateStickyItem","updateStuckItems","placeHolderNode","boundingElement","offset","disableWhenStacked","matches","stickyOffset","getOffset","parseInt","scrollPosition","placeHolderNodeCurrentTop","getBoundingClientRect","_stickyNode$firstElem","stickyItemHeight","height","firstElementChild","stickyItemBottomPosition","bottom","item","isNodeStuck","addStuckItem","removeStuckItem","node","count","stuckNodesLength","nodeRect","stuckNode","stuckNodeRect","horizontallyOverlaps","nodeFound","topbarElement","querySelector","selector","clientHeight","document","body","documentElement","rect1","rect2","rect1Left","rect1Right","rect2Left","rect2Right"],"mappings":"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","sourcesContent":["import debounce$1 from 'lodash/debounce';\nimport { stackedContent } from '../breakpoints.js';\nimport { spacingLoose } from '@shopify/polaris-tokens';\nimport { scrollable, dataPolarisTopBar } from '../../components/shared.js';\nimport { getRectForNode } from '../geometry.js';\n\nconst SIXTY_FPS = 1000 / 60;\nclass StickyManager {\n  constructor(container) {\n    this.stickyItems = [];\n    this.stuckItems = [];\n    this.container = null;\n    this.topBarOffset = 0;\n    this.handleResize = debounce$1(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    this.handleScroll = debounce$1(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n\n  registerStickyItem(stickyItem) {\n    this.stickyItems.push(stickyItem);\n  }\n\n  unregisterStickyItem(nodeToRemove) {\n    const nodeIndex = this.stickyItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stickyItems.splice(nodeIndex, 1);\n  }\n\n  setContainer(el) {\n    this.container = el;\n\n    if (isDocument(el)) {\n      this.setTopBarOffset(el);\n    }\n\n    this.container.addEventListener('scroll', this.handleScroll);\n    window.addEventListener('resize', this.handleResize);\n    this.manageStickyItems();\n  }\n\n  removeScrollListener() {\n    if (this.container) {\n      this.container.removeEventListener('scroll', this.handleScroll);\n      window.removeEventListener('resize', this.handleResize);\n    }\n  }\n\n  manageStickyItems() {\n    if (this.stickyItems.length <= 0) {\n      return;\n    }\n\n    const scrollTop = this.container ? scrollTopFor(this.container) : 0;\n    const containerTop = getRectForNode(this.container).top + this.topBarOffset;\n    this.stickyItems.forEach(stickyItem => {\n      const {\n        handlePositioning\n      } = stickyItem;\n      const {\n        sticky,\n        top,\n        left,\n        width\n      } = this.evaluateStickyItem(stickyItem, scrollTop, containerTop);\n      this.updateStuckItems(stickyItem, sticky);\n      handlePositioning(sticky, top, left, width);\n    });\n  }\n\n  evaluateStickyItem(stickyItem, scrollTop, containerTop) {\n    const {\n      stickyNode,\n      placeHolderNode,\n      boundingElement,\n      offset,\n      disableWhenStacked\n    } = stickyItem;\n\n    if (disableWhenStacked && stackedContent().matches) {\n      return {\n        sticky: false,\n        top: 0,\n        left: 0,\n        width: 'auto'\n      };\n    }\n\n    const stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(spacingLoose, 10) : this.getOffset(stickyNode);\n    const scrollPosition = scrollTop + stickyOffset;\n    const placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;\n    const top = containerTop + stickyOffset;\n    const width = placeHolderNode.getBoundingClientRect().width;\n    const left = placeHolderNode.getBoundingClientRect().left;\n    let sticky;\n\n    if (boundingElement == null) {\n      sticky = scrollPosition >= placeHolderNodeCurrentTop;\n    } else {\n      var _stickyNode$firstElem;\n\n      const stickyItemHeight = stickyNode.getBoundingClientRect().height || ((_stickyNode$firstElem = stickyNode.firstElementChild) == null ? void 0 : _stickyNode$firstElem.getBoundingClientRect().height) || 0;\n      const stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;\n      sticky = scrollPosition >= placeHolderNodeCurrentTop && scrollPosition < stickyItemBottomPosition;\n    }\n\n    return {\n      sticky,\n      top,\n      left,\n      width\n    };\n  }\n\n  updateStuckItems(item, sticky) {\n    const {\n      stickyNode\n    } = item;\n\n    if (sticky && !this.isNodeStuck(stickyNode)) {\n      this.addStuckItem(item);\n    } else if (!sticky && this.isNodeStuck(stickyNode)) {\n      this.removeStuckItem(item);\n    }\n  }\n\n  addStuckItem(stickyItem) {\n    this.stuckItems.push(stickyItem);\n  }\n\n  removeStuckItem(stickyItem) {\n    const {\n      stickyNode: nodeToRemove\n    } = stickyItem;\n    const nodeIndex = this.stuckItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stuckItems.splice(nodeIndex, 1);\n  }\n\n  getOffset(node) {\n    if (this.stuckItems.length === 0) {\n      return 0;\n    }\n\n    let offset = 0;\n    let count = 0;\n    const stuckNodesLength = this.stuckItems.length;\n    const nodeRect = getRectForNode(node);\n\n    while (count < stuckNodesLength) {\n      const stuckNode = this.stuckItems[count].stickyNode;\n\n      if (stuckNode !== node) {\n        const stuckNodeRect = getRectForNode(stuckNode);\n\n        if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {\n          offset += getRectForNode(stuckNode).height;\n        }\n      } else {\n        break;\n      }\n\n      count++;\n    }\n\n    return offset;\n  }\n\n  isNodeStuck(node) {\n    const nodeFound = this.stuckItems.findIndex(({\n      stickyNode\n    }) => node === stickyNode);\n    return nodeFound >= 0;\n  }\n\n  setTopBarOffset(container) {\n    const topbarElement = container.querySelector(`:not(${scrollable.selector}) ${dataPolarisTopBar.selector}`);\n    this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;\n  }\n\n}\n\nfunction isDocument(node) {\n  return node === document;\n}\n\nfunction scrollTopFor(container) {\n  return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;\n}\n\nfunction horizontallyOverlaps(rect1, rect2) {\n  const rect1Left = rect1.left;\n  const rect1Right = rect1.left + rect1.width;\n  const rect2Left = rect2.left;\n  const rect2Right = rect2.left + rect2.width;\n  return rect2Right < rect1Left || rect1Right < rect2Left;\n}\n\nexport { StickyManager };\n"]},"metadata":{},"sourceType":"module"}